
## 정규 표현식 패턴 지정을 더 간단히

- *와 +는 Bracket포현과 조합하면 그 문자의 반복이 아니라 그 표현의 반복이 된다 

    
```

* : 직전 문자가 0번 이상 반복됨
+ : 직전 문자가 1번 이상 반복됨


[0-9]+ # 모든 숫자를 뜻함(ex, 1, 100, 2030210 ...)


# category100a -> category-100-a 로 바꾸고 싶은 경우 
# 아래처럼 간단하게 표시 가능 

"s/category(100|200|300)/category-\1-/" 
"s/category([0-9]+)/category-\1-/"


[a-z]+ # 소문자 알파벳이 연속된 문자열
[A-Z}[a-z]+ # 대문자 알파벳 한글자 뒤에 소문자가 오는 영단어 

```

- 부정형
    - ^(햇 or 캐럿)을 여는 대괄호 바로 다음에 적으면 bracket 표현의 의미가 반전된다 
    - [a-d] : a,b,c,d
    - [^a-d] : a,b,c,d 제외한 모두 

```
"s/(192.168.11.150|192.168.11.160|penguin):3000/\1:13000/"

http://192.168.11.150:3000/ -> http://192.168.11.150:13000/
http://penguin:3000/ -> http://penguin:13000/

# 192.168.11.150와 penguin 부분에서는 : 가 나오지 않는다 

"s#(://[^:]+):3000/#\1:13000/#"
-> :// 뒤에 : 이외의 문자가 1회 이상 연속된다
-> /를 정규 표현식 안에서 사용하므로 구분자로 #를 사용한다 



```

```

# 들여쓰기로 스페이스가 2개, 3개, 4개인 경우
- abcde
    - abcd
        - abde
            -abdd - 
        
        

"s/( |  |   )- /\1* /"

-> 들여쓰기가 1개인 항목은 치환되지 않는다
-> 문장 중간에 있는 - 까지 치환될 수 있다 


# Bracket 표현의 부정형아 아닌 곳에서 ^을 사용하면 줄 시작을 의미한다 

"s/a/b/" 
-> 문장 어디에 있던 a를 b로 치환

"s/^a/b"
-> 줄 첫머리에 있는 a만 b로 치환 


# 따라서 아래와 같이 수정하면 맨 처음이 -로 시작하는 부분만 *로 치환된다 

"s/(^ - / * /"

# 깊이가 다르지만 -로 시작하는 부분을 *로 바꾸소 싶은 경우
"s/^( +)- /\1* /"



```

```
# 문장 끝을 강제적으로 줄바꿈하는 경우 
# 정규표현식은 $기호는 그 위치가 줄 끝이라는 것을 의미한다 

"s/a$/b/"
-> 문장 끝에 있는 a만 b로 치환

# 문장 끝의 마침표만 줄바꿈하고 싶은 경우 
"s/ .$/.  /  
# 두번째 . 뒤에는 스페이스 2개
```

- Bracket 표현과 +와 *를 조합해서 특정 종류의 문자만 연속된 문자열을 표현가능
- Bracket 표현의 여는 대괄호 뒤에 바로 ^를 쓰면 부정형
- ^를 사용하면 줄 시작에만 있는 대상 치환가능
- $를 사용하면 줄 끝에만 있는 대상 치환 가능

```
sed 명령어 -e 옵션은 여러번 지정가능 하므로 아래와 같이 파이프 라인 없이 쓸 수 있다 

sed -r -e "s/Window XP/window/gi \
       -e "/([A-D])-/\1-0/" 


```

- 정규표현식에서
    - v : 줄 시작을 의미
    - $ : 줄 끝을 의미


- vim 명령어 모드
    - ^ : 현재 줄 처음으로 커서를 이동시킴
    - $ : 현재 줄 끝으로 커서를 이동시킴 

## Reference

  - [만화로 배우는 리눅스 시스템 관리](http://www.yes24.com/Product/Goods/32402055?Acode=101)
